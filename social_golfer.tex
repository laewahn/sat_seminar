\documentclass[a4paper]{scrartcl}

\usepackage{balance}  % to better equalize the last page
\usepackage{graphics} % for EPS, load graphicx instead
\usepackage{url}      % llt: nicely formatted URLs
\usepackage{amsmath}
\usepackage{mdframed}
\usepackage[table]{xcolor}

\title{A symmetry breaking encoding for the social golfer problem}
\author{Dennis Lewandowski}
\date{2014-07-11}

\begin{document}

\maketitle

\section{Abstract}

\section{Introduction}

A lot of effort is put into developing faster and better SAT solvers every year. With the solvers becoming more efficient, it becomes more attractive to use SAT solving even for problems that do not occur naturally encoded in SAT, such as combinatorial problems or constraint problems. Transferring non-SAT problems into SAT-problems can yield several inefficiencies. A constraint problem that, stated in its original form, consists of only few constraints can grow into millions of clauses when converted into SAT. Also, converting a problem into SAT , depending on the encoding that was chosen, might result in formulas that are not as intuitively and easy to understand as the original problem and therefore it might be hard to extend the problem to include further constraints and maintain it on the long run.

While a lot of research is done on optimizing SAT solvers, a great deal of optimization can be achieved using an optimal encoding of the problem. When choosing an encoding for a problem, one has to make a trade-off between different aspects of the encoding. An encoding could aim be intuitive and understandable. It could be desired to have a minimum set of variables, minimizing the space of possible variable assignments and therefore speeding up computation. It could take into account specific aspects of the very nature of the problem itself, such as symmetries in combinatorial problems.

\subsection{The Social Golfer Problem}

This paper will take a look into an encoding of the social golfer problem. The social golfer problem presents a class of highly symmetrical combinatorial problems. The original social golfer problem is stated as follows:

\begin{mdframed}[skipabove=\baselineskip, skipbelow=\baselineskip, leftmargin=20, rightmargin=20]

Given the following constraints, find a schedule of play for these golfers for as many weeks as possible:

\begin{enumerate}
    \item A golf club has 32 members.
    \item Each member plays golf once in a week.
    \item Golfers always play in groups of 4
    \item No golfer plays in the same group as any other golfer twice
\end{enumerate}

\end{mdframed}

% TODO: Mehr sinnvolle w-p-g Tupel finden...
As the number of weeks, the number of players and the size of the groups in the original problem is generalizable into a triple w-p-g, with w being the number of weeks to play, p being the number of players per group and g being the number of groups. By entering distinct values into the triple, one can construct other well known combinatorial problems. A tuple of 1-2-(n/2) represents the problem of constructing a round-robin tournament schedule, where n is the number of overall players. Another tuple for a well known problem is 7-3-5, which resembles Kirkman's Schoolgirl Problem: ``Fifteen young ladies in a school walk out three abreast for seven days in succession: it is required to arrange them daily so that no two shall walk twice abreast.''. The Social Golfer Problem itself is described by the tuple w-4-8. The overall goal is to find a maximal value for w. With 32 players and each player facing 3 new other players each week, w can not be greater than 10.


\subsection{Symmetries in Combinatorial Problems}

When given a combinatorial problem, in which instances are grouped together following a set of constraints, often times the order of instances within a group is considered irrelevant. Often times, as in the Social Golfer Problem, the order of groups itself is also considered irrelevant. Take for example the following excerpt of a possible assignment for Kirkman's Schoolgirl Problem:

\begin{table}[h]
\centering
\begin{tabular}{| l | l | l | l| l | l |}
\hline
Sunday & ABC & DEF & GHI & JKL & MNO \\
\hline
Monday & ADH  & BEK & CIO & FLN & GJM \\
\hline
\end{tabular}
\end{table}

The solution obviously stays valid if the days or the groups are changed within:

\begin{table}[h]
\centering
\begin{tabular}{| l | l | l | l| l | l |}
\hline
\emph{Sunday} & ADH  & BEK & CIO & FLN & GJM \\
\hline
\emph{Monday} & ABC & DEF & GHI & JKL & MNO \\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{| l | l | l | l| l | l |}
\hline
Sunday & \emph{DEF} & \emph{ABC} & GHI & JKL & MNO \\
\hline
Monday & ADH  & BEK & CIO & \emph{GJM} & \emph{FLN}\\
\hline
\end{tabular}
\end{table}

One can even change the order of entities within each group without making the solution invalid.

% TODO: 'non-solutions' ist crap. Ausserdem genauere Verwendung von 'solutions' und 'assignments'
The presented assignments are called \emph{symmatrical}. Symmetrical assignments form equivalence classes that will either contain only solutions or no solutions [Smith 2001]. When a partial assignment is proven to lead to no solution, all symmetrical assignments will also lead to no solution. Symmetries within a solution space therefore produce redundant search paths, which slow down backtracking search. When a problem has no solution, the space of possible solutions can be reduced by removing symmetrical non-solutions.

Symmetries can be removed in the following ways:

\begin{enumerate}
\item Remodel the problem
\item Add more constraints to the model
\item Avoid symmetrically equivalent states during search
\end{enumerate}

The goal of remodeling the problem is to achieve a model that has less inherent symmetries. For example by enumerating the instances or groups within a problem will yield a highly symmetrical solution space, since the entities and groups are modeled as to be distinguishable. Modeling the problem without any symmetries often times leads to the use of variables that are highly abstracted and takes a lot of effort. Often times, the effort of finding a model with no symmetry outnumbers the extra time the solver needs to solve the problem using a model with symmetries.

By adding constraints to the model in order to reduce symmetry, exhaustive search can be speed up, while the original modeling of the problem stays the same. The additional constraints may produce computation overhead, which may in turn negate the effect of a smaller solution space. In turn, due to the additional constraints, first-solution-search can be slowed down significantly [Prestwich].

In order to avoid symmetrical equivalent states during search, a specialized solver is needed. Since such a solver produces computation overhead between branching decisions, such a solver would no longer be efficient for solving problems with less to no symmetry.

% SAT Competition 2014 
%   http://satcompetition.org/2014/ 
%   http://www.satcompetition.org/

% CSSC 
%   http://aclib.net/cssc2014/

% https://en.wikipedia.org/wiki/WalkSAT
% https://en.wikipedia.org/wiki/DPLL_algorithm
% https://en.wikipedia.org/wiki/SAT_solver#Algorithms_for_solving_SAT
% https://dl.acm.org/citation.cfm?id=1644330.1644348&coll=DL&dl=GUIDE&CFID=376735803&CFTOKEN=39985701
% https://dl.acm.org/results.cfm?h=1&cfid=376735803&cftoken=39985701
% http://www.satlive.org/
% http://www.satisfiability.org/



\section{Encoding of the social golfer problem}

In this section we encode the constraints of the Social Golfer Problem. The first group of constraints deals with the number of groups a golfer can be assigned to, the number of weeks that a group can be assigned to, et cetera. We will refer to this as \emph{``external constraints''}, as they set the framework within which we can assign golfers to groups and groups to weeks.

The second group of constraints deals with the rule that each golfer is only allowed to play with each other player once. We will refer to this constraint as \emph{``internal constraint''}, as it deals with conflicts occuring in an assignment which is valid within the external constraints.


\subsection{Modeling external constraints}

In order to model the Social Golfer Problem, we first need to define a model that represents whether a certain golfer plays in a certain week within a certain group. In addition to this, our model will also state that a given golfer is at a certain position within a group. With respect to eliminating symmetries within the model, this is certainly counter-intuitive. By introducing any kind of order into a set of changeable entities, symmetries will be introduced. However, modelling it this way allows to state most constraints as at-most-one and at-least-one clasues, making the constraints more intuitive.

Let $x = p \times g$ be the number of players. The first variable introduced to our model is $\text{GOLFER}_{ijkl}$, with $1 \leq i \leq x$, $1 \leq j \leq p$, $1 \leq k \leq g$ and $1 \leq l \leq w$.



The fact that each golfer plays in at least one group every week is modeled as follows:

\begin{equation}
\label{form:everyone_plays}
% Every golfer must play in every week in at least one group at at least one position
\centering
    \bigwedge \limits_{i=1}^x 
    \bigwedge \limits_{l=1}^w 
    \bigvee \limits_{j=1}^p
    \bigvee \limits_{k=1}^g 
    \text{GOLFER}_{ijkl}
\end{equation}

To make sure that no golfer is assigned to more than on position inside a group, we'll add the following clauses:

\begin{equation}
% When a golfer plays at a position inside a group, he can not play on any other position in the same group
\centering
    \bigwedge \limits_{i=1}^x 
    \bigwedge \limits_{l=1}^w 
    \bigwedge \limits_{j=1}^p
    \bigwedge \limits_{k=1}^g 
    \bigwedge \limits_{m=j+1}^p 
    % \neg 
    \text{GOLFER}_{ijkl} 
    \to
    % \vee 
    \neg \text{GOLFER}_{imkl}
\end{equation}

To make sure that no golfer plays in more than one group within the same week, the following clauses are added:

\begin{equation}
% When a golfer plays at a position inside a group within one week, he cannot play at any position and group in the same week
\centering
    \bigwedge \limits_{i=1}^x 
    \bigwedge \limits_{l=1}^w 
    \bigwedge \limits_{j=1}^p
    \bigwedge \limits_{k=1}^g 
    \bigwedge \limits_{m=k+1}^g 
    \bigwedge \limits_{n=j+1}^p 
    % \neg 
    \text{GOLFER}_{ijkl} 
    \to
    % \vee 
    \neg \text{GOLFER}_{inml}
\end{equation}

The next set of clauses ensures that every position in each group within each week is assigned to at least one golfer.

\begin{equation}
% On every day in every group at every position there is at least one golfer playing
\centering
    \bigwedge \limits_{l=1}^w 
    \bigwedge \limits_{k=1}^g 
    \bigwedge \limits_{j=1}^p
    \bigvee \limits_{i=1}^x 
    \text{GOLFER}_{ijkl}
\end{equation}


Finally, the following set of clauses ensure that each position within each group is at most taken by one golfer.

\begin{equation}
% If within a week within a group a position is already taken by a golfer, this position can not be taken by another golfer
\centering
    \bigwedge \limits_{l=1}^w 
    \bigwedge \limits_{k=1}^g 
    \bigwedge \limits_{j=1}^p
    \bigwedge \limits_{i=1}^x 
    \bigwedge \limits_{m=i+1}^x 
    % \neg 
    \text{GOLFER}_{ijkl} 
    \to
    % \vee 
    \neg \text{GOLFER}_{imkl}
\end{equation}


\subsection{Modeling internal constraints}

The last constraint we need to add is the one that guarantees that no golfer plays in the same group as any other golfer twice. To ensure this, we will introdoce a construction that is called a ``ladder matrix''.


\subsubsection{Constructing the ladder matrix}

\begin{table}[h]
\centering
\label{ladder:example}
\begin{tabular}{ l | l | l | l | l | l | l }

    & 1.1 & 1.2 & 2.1 & 2.2 & 3.1 & 3.2 \\
\hline
3.4 & --- & --- & --- & --- & --- & --- \\
2.3 & --- & --- & --- & --- & --- & --- \\
2.4 & --- & --- & --- & --- & --- & --- \\
1.2 & --- & --- & --- & --- & --- & --- \\
1.3 & --- & --- & --- & --- & --- & --- \\
1.4 & --- & --- & --- & --- & --- & --- \\

\end{tabular}
\caption{The ladder variables presented as a table for the Social Golfer Problem 3-2-2. Each row represents a unique combination of two players. Each column represents a group within a week.}
\end{table}

A ladder matrix is built with a set of auxilliary boolean ladder variables. The ladder variables will indicate whether two players are scheduled to play in a certain week within a certain group. We will denote the ladder variables as $\text{Ladder}_{yz}$, where $1 \leq y \leq {x \choose 2}$ and $1 \leq z \leq g \times w$. Values of $y$ indicate a match between two players, values of $z$ represent a combination of a week and a team number (see table \ref{ladder:example}). 



Because we constructed variables for exactly ${x \choose 2}$, we end up with a set of all combinations of weeks and groups for each unique pair of two players. The next thing we need to do is to make sure that once a pair of players is assigned into one group within one week, this pair is not assigned any other group in any other week.

Consider the ladder variables for a fixed pair of players. We define such a row to be valid if and only if it is built of a sequence of zero or more true assignments, followed only by false assignments. So once a ladder variable within a row is set to false, each subsequent variable must also be false. This is achieved by adding clause \ref{ladder:propagation}:

\begin{equation}
\label{ladder:propagation}
\centering
    \bigwedge \limits_{y=1}^{{x \choose 2}}
    \bigwedge \limits_{z=1}^{(g \times w)-1}
    \text{Ladder}_{yz+1}
    \to
    \text{Ladder}_{yz}
\end{equation}

Given this encoding, we define that a pair of players is assigned a group $k$ and a week $l$ when the ladder variable in their respective row is false for the first time. As an example consider the following assignment of ladder variables for the match between the players 1 and 2:

\begin{table}[h]
\centering
\begin{tabular}{ l | l | l | l | l | l | l }
    & 1.1 & 1.2 & 2.1 & 2.2 & 3.1 & 3.2 \\
\hline
1.2 & T & T & \textbf{T} & \textbf{F} & F & F \\
\end{tabular}
\end{table}

With respect to \ref{ladder:propagation} this is a valid assignment of ladder variables. The change from true assignments to false assignments from column 2.1 to column 2.2 (emphasized in bold) schedules player 1 and 2 to play within group 1 in week 2. Because of \ref{ladder:propagation} it is no longer possible to schedule this pair of players to another group in another week. So no golfer can play with another golfer in the same group more than once.


\subsection{Matching entries of the ladder matrix to the $\text{GOLFER}$ variable}

Finally we need to link the results of the assignment of our ladder matrix to our set of external constraints. First, we introduce an auxilliary variable $\text{GOLFER'}_{ikl}$, with $1 \leq i \leq x$, $1 \leq k \leq g$ and $1 \leq l \leq w$. This variable is assigned \emph{true}, when the golfer $i$ is scheduled to play in group $k$ in week $l$. The relation to the $\text{GOLFER}_{ijkl}$ in the external constraints is established with the following set of clauses:

\begin{equation}
    \text{GOLFER'}_{ikl} \iff \bigvee \limits_{j=1}^p \text{GOLFER}_{ijkl}
\end{equation}


\section{Symmetry breaking}

As already mentioned when defining the GOLFER variable, our model turns out to be highly symmetrical. Besides ordering weeks, groups and players, we introduced more symmetries by ordering players within a group into certain positions. A model with minimal symmetries would have to model players, weeks, groups and positions within as completely interchangeable. However, finding such an encoding might cost more effort than it could be counterbalanced with an efficient non-symmetrical encoding. 

In order to break the symmetry introduced through our encoding, we will add some symmetry-breaking clauses to the encoding. The main idea here is to force entities into a lexicographical order. First, we will enforce an increasing numerical order onto players within the same group, by prohibiting assignments where players with indices smaller than the player at a certain position are placed at positions with a higher index than the latter:

\begin{equation}
\centering
    \bigwedge \limits_{i=1}^x
    \bigwedge \limits_{j=1}^p
    \bigwedge \limits_{k=1}^g
    \bigwedge \limits_{l=1}^w
    \bigwedge \limits_{m=1}^{i-1}
    \text{GOLFER}_{ijkl}
    \to
    \neg \text{GOLFER}_{m(j+1)kl}
\end{equation}

More symmetries can be broken by forcing the first players of each group within one week into a lexicographical order. This is achieved by setting golfer number 1 as the first golfer in the first group within every week. Further we disallow assignments where golfers with a smaller index than the first golfer within a group are assigned the first golfer in a group with a bigger index than the latter:

\begin{equation}
\centering
    \bigwedge \limits_{i=1}^x
    \bigwedge \limits_{k=1}^g
    \bigwedge \limits_{l=1}^w
    \bigwedge \limits_{m=1}^{i-1}
    \text{GOLFER}_{i1kl}
    \to
    \neg \text{GOLFER}_{m1(k+1)l}
\end{equation}

Lastly we will break symmetries between weeks. For this, we enforce a lexicographical order onto the second players within each group between weeks in a manner similar to the ones before:

\begin{equation}
\centering
    \bigwedge \limits_{i=1}^x
    \bigwedge \limits_{k=1}^g
    \bigwedge \limits_{l=1}^w
    \bigwedge \limits_{m=1}^{i-1}
    \text{GOLFER}_{i2kl}
    \to
    \neg \text{GOLFER}_{m2k(l+1)}
\end{equation}


\section{Conclusion}

- [ ] Removing symmetries can speed up the SAT solving by reducing the
      solution space
- [ ] Removing symmetries adds extra costs to the modeling process
    - [ ] Trade-off: costs for eliminating symmetries vs. cost for
          longer run of solver
    - [ ] Does not always pay off (as results in the paper show)
- [ ] Social golfer encoding made a trade-off between intuitive model
      and a model suited to avoid symmetries


\end{document}